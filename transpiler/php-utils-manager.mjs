/**
 * PHP Utility Functions Manager
 * 
 * Manages the generation and tracking of PHP utility functions
 * that provide accurate PHP semantics in JavaScript.
 */

import { promises as fs } from 'fs';
import path from 'path';

/**
 * Registry of all available PHP utility functions
 */
export const UTILITY_FUNCTIONS = {
    empty: {
        name: 'empty',
        description: 'PHP empty() - checks if a value is considered empty',
        signature: '(val)',
        body: `(val) {
    if (val === null || val === undefined || val === false) return true;
    if (val === 0 || val === "0" || val === "") return true;
    if (Array.isArray(val) && val.length === 0) return true;
    if (typeof val === 'object' && Object.keys(val).length === 0) return true;
    return false;
}`
    },
    
    isset: {
        name: 'isset',
        description: 'PHP isset() - checks if a variable is set and not null',
        signature: '(...vars)',
        body: `(...vars) {
    for (const v of vars) {
        if (v === null || v === undefined) return false;
    }
    return true;
}`
    },
    
    array_key_exists: {
        name: 'array_key_exists',
        description: 'PHP array_key_exists() - checks if a key exists in an array/object',
        signature: '(key, obj)',
        body: `(key, obj) {
    if (obj === null || obj === undefined) return false;
    if (Array.isArray(obj)) return key in obj;
    if (typeof obj === 'object') return key in obj;
    return false;
}`
    }
};

/**
 * Utility Module Manager
 */
export class UtilityManager {
    constructor(options = {}) {
        this.utilityStyle = options.utilityStyle || 'inline';
        this.utilityModule = options.utilityModule || 'php-utils';
        this.usedFunctions = new Set();
    }

    /**
     * Register that a utility function is being used
     */
    registerFunction(name) {
        if (UTILITY_FUNCTIONS[name]) {
            this.usedFunctions.add(name);
            return true;
        }
        return false;
    }

    /**
     * Get the call syntax for a utility function
     */
    getCallSyntax(name, args) {
        if (this.utilityStyle === 'none') {
            return null;
        }
        
        if (this.utilityStyle === 'module') {
            return `${this.utilityModule}.${name}(${args})`;
        }
        
        // inline style
        return `__${name}(${args})`;
    }

    /**
     * Generate inline utility functions code
     */
    generateInlineFunctions() {
        if (this.utilityStyle !== 'inline' || this.usedFunctions.size === 0) {
            return '';
        }

        let output = '\n// PHP Utility Functions\n';
        for (const name of this.usedFunctions) {
            const func = UTILITY_FUNCTIONS[name];
            if (func) {
                output += `// ${func.description}\n`;
                output += `function __${name}${func.body}\n\n`;
            }
        }
        return output;
    }

    /**
     * Get import statement for module style
     */
    getModuleImport() {
        if (this.utilityStyle !== 'module') {
            return '';
        }
        return `import * as ${this.utilityModule} from './${this.utilityModule}.js';\n`;
    }

    /**
     * Generate a standalone utility module file
     */
    async generateUtilityModule(outputDir, functionNames = null) {
        const functionsToExport = functionNames || Object.keys(UTILITY_FUNCTIONS);
        
        let content = `/**
 * PHP Utility Functions Module
 * 
 * Provides JavaScript implementations of PHP functions
 * with accurate PHP semantics.
 * 
 * Auto-generated by php2js transpiler
 * Generated: ${new Date().toISOString()}
 */

`;

        for (const name of functionsToExport) {
            const func = UTILITY_FUNCTIONS[name];
            if (func) {
                content += `/**
 * ${func.description}
 * @param ${func.signature}
 */
export function ${name}${func.body}

`;
            }
        }

        // Add default export with all functions
        content += `// Default export with all functions\n`;
        content += `export default {\n`;
        for (const name of functionsToExport) {
            content += `    ${name},\n`;
        }
        content += `};\n`;

        const modulePath = path.join(outputDir, `${this.utilityModule}.js`);
        await fs.mkdir(outputDir, { recursive: true });
        await fs.writeFile(modulePath, content, 'utf8');
        
        return modulePath;
    }

    /**
     * Check if utility module needs to be created/updated
     */
    async ensureUtilityModule(outputDir) {
        if (this.utilityStyle !== 'module' || this.usedFunctions.size === 0) {
            return null;
        }

        const modulePath = path.join(outputDir, `${this.utilityModule}.js`);
        
        // Check if module exists
        try {
            await fs.access(modulePath);
            // Module exists, check if it has all needed functions
            const content = await fs.readFile(modulePath, 'utf8');
            
            // Simple check: does the file contain all needed function exports?
            let needsUpdate = false;
            for (const name of this.usedFunctions) {
                if (!content.includes(`export function ${name}`)) {
                    needsUpdate = true;
                    break;
                }
            }
            
            if (needsUpdate) {
                // Read existing functions and merge with new ones
                const existingFunctions = new Set();
                for (const name of Object.keys(UTILITY_FUNCTIONS)) {
                    if (content.includes(`export function ${name}`)) {
                        existingFunctions.add(name);
                    }
                }
                
                // Merge with used functions
                const allFunctions = new Set([...existingFunctions, ...this.usedFunctions]);
                await this.generateUtilityModule(outputDir, Array.from(allFunctions));
            }
        } catch (error) {
            // Module doesn't exist, create it with used functions
            await this.generateUtilityModule(outputDir, Array.from(this.usedFunctions));
        }
        
        return modulePath;
    }

    /**
     * Reset the manager for a new transpilation
     */
    reset() {
        this.usedFunctions.clear();
    }
}

/**
 * Create a utility manager instance
 */
export function createUtilityManager(options) {
    return new UtilityManager(options);
}
